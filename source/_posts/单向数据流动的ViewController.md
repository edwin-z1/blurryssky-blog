---
title: 单向数据流动的ViewController
date: 2019-03-14 10:33:53
tags:
---

# 单向数据流动的ViewController

## [keynote和demo下载地址]()

## keynote 1 

今天想和大家分享一些关于架构方面的思考，灵感主要来源于前段时间读的一本书[《App架构》书籍地址](https://objccn.io/products/app-architecture)和一些网上的博客内容，读完后结合自己平时的一些使用经验思考，个人觉得有很多收获。这次分享我会以一个叫单向数据流的主题思想来贯穿全部内容，其中会涉及到的内容包括代码规范、MVC、MVVM、响应式系统等，以此来提供对ViewController做优化时的一些思路。

思考架构这个事情很有意义，当一个项目发展到一定规模以后，工程的架构会极大的影响之后的开发、维护成本以及对bug的控制。由于编程的自由度很高，每个人都可能根据自己的经验或者从别处的借鉴去做一些架构的畅想和修改，但是修改之后的结果有可能不好判断这样的修改是否真的好。通过对架构的进一步思考，总结过去的不足，来构建更加合理的代码结构。

>什么是data flow，就是数据在你的app里流动的路线，就像人体血管里的血液，滋养着各个器官的运作。

架构在表现上来说，就是将代码按一定规则分散到各个文件里，当拆分之后，必然就会引入额外的引用和反馈机制，也就是赋值和代码回调。有些架构文章不停的介绍这些额外的代价，却没有讲清楚为什么要这样做，所以很多时候看到一个新的架构就觉得有点混乱。再后来就会慢慢发现，架构的形式其实并不是最重要的，重要的是架构里数据流动的路线，如果明白了一个架构里的数据流动方向，就很容易能理解为什么要这样做，也没有必要去执着是MVC还是MVVM，依照数据流的流动方向思考，代码是易于理解的、逻辑一致的，而最终的结果是bug是比较难以产生的。这里我们要介绍的是单向数据流，也就是数据总是按同一个方向流动，推荐阅读[单向数据流动的函数式 viewcontroller](https://onevcat.com/2017/07/state-based-viewcontroller/)和[iOS应用层架构之CDD](http://mrpeak.cn/blog/cdd/)。

## keynote 2

光做思想实验不行，我们从一个比较具象化的问题入手。我写了一个ToDoList的demo，叫BoringToDo，因为这是一个初级到让人感到无聊的工程，我是希望通过一个简单的app里来阐述单向数据流的思想，避免让问题变得复杂或者说偏离我们主要需要聚焦的架构问题，我们先看一下demo的使用视频。

我总结了一下它的主要功能，分别是：

1. 表格展示一个待办列表，加载时会有一定延时，每一个待办事项有开关来标明是否完成，待办事项可以通过右滑来删除。
2. 左上角的开关代表总开关，只有总开关打开的时候，才能打开待办事项的开关。
3. 使用右上角的加号添加一个待办事项。
4. 导航栏标题后的数字会随着待办事项的完成而变化，数字代表未完成的待办个数。
5. 所有的改动都会被持久化到本地。

这个应用我做了3个版本的架构，最开始是我们熟知的MVC，之后的版本会一点一点的改进。
大概了解之后，需要简单的看下代码，来比较几次修改之间的具体差别。

观看代码顺序：

（浏览代码...）

1. 通过观察界面，我们知道左右有两个导航栏按钮，左边的开关通过`UserDefaults`来读取开关状态，相关代码被分散到**Category**里。
2. 设置了`UIRefreshControl`并且触发了刷新来获取数据，数据通过`NSKeyedUnarchiver`从本地解档，看看model，只是简单的设置了属性声明和实现了`NSCoding`协议。数据加载后刷新了UI。
3. 下面是`UITableViewDataSource`的实现，当model被设置到cell里的时候，cell也刷新了UI。
4. 接下来是交互逻辑，左边开关的交互直接设置了`UserDefaults`；右边的+号会产生一个新的model实例并且刷新UI。
5. 左滑删除会操作model，更新UI，保存本地。
6. 在cell里的交互，把所有信息交给viewcontroller处理，viewcontroller会保存数据改动和更新UI。

## keynote 3

我们分析一下demo中的数据流动情况：

* 读取本地数据：viewcontroller读取了model，然后更新UI。
* 增加：viewcontroller创建了model, 然后更新UI。
* 删除：viewcontroller删除了model, 然后更新UI。
* 更新：cell通过交互事件先进行了UI更新，然后通知viewcontroller，viewcontroller修改model并再次对UI更新。

cell这里由于使用了`UISwitch`，系统会强制对UI立刻进行更新，导致更新UI的逻辑顺序和之前3种发生了变化，但之后仍然通过viewcontroller->model->view的顺序进行了更新。

就目前来看，这就是一个单向数据流的viewcontroller。无论事件从哪个地方产生，都将产生同样的路径来修改数据和更新UI，杜绝了因为状态不一致而产生的bug。总体来说，逻辑划分比较清晰，model和cell的功能都特别透明，而viewcontroller的代码逻辑略多一些。

常见的MVC问题：

1. Massive ViewController。太多的逻辑最后都放在了viewcontroller里。
2. 缺少观察机制。这里说的并不只是指KVO，而是一种反馈机制。我们总是在viewcontroller里修改了model后，主动对view进行更新，而不是通过model的反馈来更新，这其实潜在的增加了问题产生的风险。


## keynote 4

我们先看第一个问题，解决*Massive ViewController*的办法如下：

* Storyboard/Xib。尽可能的把代码用这种方式构建，毕竟都是一些view的初始化配置代码。
* Category(extension)。对所有的类都可以用，用于把逻辑分隔开，但是没有存储功能。
* 方法复用。就是尽量提炼大同小异方法，通过参数等控制逻辑。
* …
* 提取对象。可以无限进行下去的办法，总是可以把代码拆分到其他类，然后通过引用和回调来建立关系。
* ChildViewController。类似提取对象，只不过把对象提取成了viewcontroller，伴随的是一系列关系。

其实提取对象这个办法大家也是用的很多了，可以说我们现在进行的MVC基本都是会有提取对象的。每个人风格可能都不同，有些是manager，有些是coordinator...都是一个意思。大家对于提取对象应该包含哪些方法有一些不同，比如有些人会只包含业务处理的方法，有些人会把UI更新的方法也写进去。

接下来我们就按照提取对象的办法把刚才的工程改造一下，由于viewcontroller里包含了很多处理model层的代码，我决定把它们提出来，叫做datasource，然后通过引用和回调来与viewcontroller建立关系。

## keynote 5

（浏览代码...）

改造后数据流动情况：

* 读取本地数据：viewcontroller使用datasource读取model，datasource内部改动，datasource通过代理回调viewcontroller，然后更新UI。
* 增加：viewcontroller使用datasource创建model，datasource内部改动，datasource通过代理回调viewcontroller，然后更新UI。
* 删除：viewcontroller使用datasource删除model，datasource内部改动，datasource通过代理回调viewcontroller，然后更新UI。
* 更新：cell通过交互事件先进行了UI更新，然后通知viewcontroller，viewcontroller使用datasource修改model，datasource内部改动，datasource通过代理回调viewcontroller，然后更新UI。

在原有的MVC框架基础上，在viewcontroller和model之间多加了一层datasource，依然保持了单向数据流，任意交互事件发生后都会按照一个方向把所有的组件依次经过一遍。

现在看看刚才的问题：

1. Massive ViewController。通过分割datasource，viewcontroller只剩下一些胶水代码，足够简单了。
2. 缺少观察机制。由于datasource的引入，我们在datasource到viewcontroller之间增加了代理方法。但在model和datasource之间依然缺少观察机制。

对于model观察机制的缺失主要原因是大部分时候，主动调用方法太方便了。特别是面对同步代码，直接调用比起绕一圈写一堆代码来说要方便的多。只有当我们遇到异步代码，才会无可奈何的去选择观察机制。

## keynote 6

看看观察机制的可用技术：

* Notification将值从单一源广播给若干个收听者。这是非常强大的技术，既能够广播，又能够隔层级传递，但也正是这一原因，滥用可能导致代码层级混乱。
* KVO可以将某个对象上属性的改变报告给另一个对象。不太好用且不是很完善。
* Delegate(block)一对一的关系。上下文关系体现比较明显，和通知相对，只能一对一，如果多层依次传递会非常头疼。
* …一些自己发明的轮子。一些三方库。一些对系统的封装。
* RAC(RxSwift)。经过一段时间的使用发现，RAC的基础功能其实算是为了解决这些痛点产生的。比如delegate和block的一对一问题，无法多次赋值。通知的零散的上下文关系。KVO的不好用等。

这真的不是一篇RAC软文，但是要想流畅的使用MVVM，或者说流畅的使用提取对象这个分离代码的方法，就不得不说到RAC。
另外，我们看看MVVM的架构图。

## keynote 7

与刚才datasource的图如出一辙，只有两处改动

1. datasource改名为view-model。
2. model的观察机制被补齐了。

其实我们刚才那样的操作，就是MVVM的起源。
datasource本身其实就承担了viewmodel的工作，并且我们的数据流向都是相同的，代码分层也是相同的。毕竟datasource只是我们小范围命名出来的，我们应该给它改名为更加广泛的说法。model的观察机制补齐只是更加确保了代码正常运行，不出bug，因为通过反馈机制来进行下一步行动，比主动调用更加可靠，而且同时解决了异步问题。

刚才的datasource相当于没有结合RAC的MVVM代码，也是我们可能经常会在工程中写的，只是分层的逻辑不一样。既然讲到了这里，我们还是来看看用RAC来结合之后的代码。

我们构思一下需要做的工作，除了上面的两条再加一条即可

*3. 把view-model的代理改为RAC实现。*

（浏览代码...）

我并没有做实质性的改动，只是优化了代码。它依然是单向数据流的。任何发生的事件，都会通过同样的顺序去告知所有的层，在数据被修改后，通过反馈依次更新到UI上。现在观察机制已经补齐，虽然仍有部分是主动调用，但那确实是不得已。

到目前为止，我们就完整的构建了一个响应式MVVM的框架，它完全是数据驱动的，也就是通过数据改动后的反馈来更新UI的。其实在一个工程里，我们完全可以多种架构同时存在，也就是说小一点，仅把它作为viewcontroller的一种写法，根据情况选择合适的写法，但是单向数据流是需要一直被遵守的，并且数据反馈的机制也需要尽量完善。

## keynote 8

单向数据流已经介绍完了。接下来考虑一些延伸问题：

比如当view-model由于业务逻辑太多，再次变得臃肿的时候怎么办。
假设现在view-model有了更多功能，除了持久化，再增加网络请求和IM回调两种功能，代码行数到达了2000行。

我们还是按照之前的那些办法来处理，view-model里面不应该包含UI，也就没有sb/xib的事了；使用category或是方法复用；做完之后就是提取对象，我们可以按这些功能将view-model的功能分散到3个子工具类里，而view-model变得像viewcontroller一样，只是去调度这三个类的一些胶水代码。

对于这3个子工具类，我们好像没办法把它们变成单向数据流，比如从网络请求收到的消息，一般不会再去IM那边走一圈，反过来倒是有可能，数据返回后可能会先持久化到本地，再去更新UI。假设从网络请求和IM返回的消息，反馈到view-model，view-model需要去做本地存储，完成后再更新到UI向外输出，加入单向数据流的循环，其实持久化也可以作为单独一层提出来。

## keynote 9

再看看view层的问题，假设view层变得很复杂，按照提取对象的思想，把view拆分成多个subview，view本身又变成了管理subview的调度对象，而每个subview分别控制和反馈不同的交互事件，这次在view层不太可能产生互通的回路，所以每个subview都是单独的一条线，而view在更新自身状态后，一般直接把事件传递出来即可重新加入单向数据流。

如果每个view都有单独的数据源，或者都对应一部分单独的行为，那其实可以考虑从viewcontroller入手，直接拆分成多个childviewcontroller，每一个childviewcontroller都会分别选择使用MVC或是MVVM的写法，它会有一套完整的逻辑回路。这就像是分解因式，就看这个公因数怎么提。

## keynote 10

最后我想讨论一下为什么MVC和MVVM这么有名。

MVC有名是因为苹果官方的例子大部分都是MVC的，包括苹果的框架的设计风格，都是按照MVC的构想来的，所以我们最初接触到的就是MVC。而MVC由于存在viewcontroller职责过多的问题，必然会随着功能的复杂而变得臃肿，如果没有好的代码分层，必然会混乱。由此产生了提取对象的方法，也就是MVVM的雏形，由于多了一层分层，导致额外增加的回调大量产生，以及为了弥补原生系统架构技术的一些缺陷，为了解决观察机制的这些弊端和一些别的原因，RAC也随之诞生，并且还增加了一些处理变形、信号合并等拓展性性的功能。

我没有提到RAC解决异步的问题，因为按照数据反馈的思路来的话，其实已经解决了异步代码的问题，而RAC是把代码变得更加简洁，并且通过变形可以把连续的异步操作组合在一起功能更加强大了，它提供的是一种优化代码的功能，没有RAC的话由于反馈回路的观察机制问题，确实会把代码变得非常啰嗦，但是解决异步回调问题的是单向数据流，或者说响应式框架这种思路本身。

也有很多其他框架，它们也是一些思想，但是不太适用在iOS上，因为毕竟对原生的风格改变太大，又或者并没有比MVC或者MVVM的架构来说优秀多少，又或者没有更多的人愿意去维护和更新这些框架。

当某一层变得臃肿的时候，我们可以通过提取对象的方式去组织代码功能，把它分割成一些子功能类，在层内部被一对多的方式进行管理，或是分离出新的一层，在大的单向数据流里串行管理，这取决于每一层的输入和输出的情况。就像刚才说的持久化层，如果非常的复杂庞大，比如像微信一样，就可以考虑在viewmodel和model之间添加一层。

MVC由于controller太复杂，而产生了MVVM，那为什么没有由于viewmodel太复杂，而继续产生别的架构呢。我认为是复杂度和通用性还不够。一个App最开始是比较简单的，MVC完全够用。随着业务逻辑的增加，viewcontroller变得臃肿，viewmodel就应运而生了，这可能是大部分App的问题。而到此之后，大部分应用已经不需要再增加层了，或者说是在每一层内部分割功能再管理就足够用了。

由于MVC和MVVM是经过实践的，并且符合大部分App流程的，所以当头绪不明的时候，很适合用它们来作为一个开始。但不必限制思维在MVC或是MVVM上，在对情况熟悉以后，我们可以根据情况去添加层的处理。


